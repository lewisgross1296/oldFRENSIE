// This file is used to add material to the facemc manual page

/*! \page facemc_man FACEMC User's Manual
 *
 * \tableofcontents
 *
 * The Forward-Adjoint Continuous Energy Monte Carlo (FACEMC) code is 
 * currently interacted with through XML files and a command-line interface.
 * In the future, a python interface will also be added. In this manual the
 * individual XML files and the command line interface will be discussed.
 *
 * In every simulation, six XML files must be provided. These XML files
 * specify the geometry, the source, the estimators, the response functions,
 * the materials, and run time configuration options. The following sections 
 * will discuss the construction of each of these XML files.
 *
 * \section geometry_sec_dag Geometry Construction - DAGMC
 * In order to use DagMC as the geometry handler for a simulation, a CAD
 * geometry must be utilized. Further, the CAD file must
 * be constructed before the XML file. 
 *
 * \subsection dagmc_workflow DAGMC Workflow
 * The <a href=http://cnerg.github.io/>CNERG</a> group has put together a nice
 * document on the <a href=http://svalinn.github.io/DAGMC/usersguide/workflow.html>DAGMC workflow</a>.
 * This workflow will be reiterated and some steps specific to FACEMC will
 * also be added.
 *
 * To construct a CAD file for ray tracing using DAGMC, the following workflow 
 * should be followed:
 * <ol>
 *  <li> Create and/or prepare a solid model using the CAD/solid-modeling tool
 *       of your choice.</li>
 *  <li> Pre-process the solid model geometry in CUBIT
 *   <ul><li> Assign materials and densities</li>
 *       <li> Define boundary conditions</li>
 *       <li> Imprint & merge geometry</li>
 *       <li> Export the processed model in the ACIS format</li></ul>
 * </ol>     
 * 
 * \subsection contructing_cad_geoms Constructing CAD Geometries
 * When preparing the solid model, any software that supports the ACIS (.sat)
 * and/or the STEP (.stp, .STEP, etc) can be used. CUBIT can also be used
 * directly to construct the geometry. It is important to be aware of gaps
 * and overlaps in the model as these unwanted features will lead to lost
 * particles while FACEMC attempts to ray trace on the geometry. It is fairly
 * common for models constructed for manufacturing purposes to have tolerances
 * that are undesirable for particle transport applications. Therefore, 
 * when obtaining a CAD model from another source, it is important to be aware 
 * of its intended purpose. 
 *
 * Once a CAD geometry has been constructed, it is important to assess its
 * quality by running it in FACEMC and identifying the lost particle rate using
 * a voided geometry (simply do not define any materials). The CNERG group
 * usually considers a lost particle rate of 1/50,000 to be an acceptable
 * threshold. 
 *
 * A special volume must be created that surrounds the entire geometry of
 * interest. This geometry will be used to end particle histories that
 * enter it (see the "termination.cell" property below).
 *
 * \subsection preprocessing_model Pre-processing CAD Model using CUBIT
 * The first step in pre-processing a CAD model in CUBIT is to import it
 * into CUBIT. This step can take up to 30 minutes for very complicated CAD
 * models but will typically only take a few seconds. 
 *
 * The second step is to replace coincident surfaces with a single surface. In
 * CUBIT this is called imprinting and merging. To imprint, use the following
 * command in cubit:
 * \code{.unparsed}
 * imprint body all
 * \endcode
 * If the imprint is successful, the geometry must be merged. A tolerance for
 * this process can be set, which may be useful for certain geometries. To 
 * set the merge tolerance and to merge the geometry, use the following 
 * commands:
 * \code{.unparsed}
 * merge tol 5e-7
 * merge all 
 * \endcode
 * This process will be quite fast for modest sized geometries. However, expect
 * up to a few hours for complex geometries.
 *
 * The third step is to assign properties to volumes and surfaces. The
 * assignment of properties to volumes and surfaces is done by creating groups
 * in CUBIT. The name of the group determines the property of the volumes
 * and/or surfaces contained in the group. To create a group, the following
 * command should be used:
 * \code{.unparsed}
 * group "group.name" add vol 5 8 10 to 20
 * group "group.name" add surf 1 2 3
 * \endcode
 * There are several properties that are often set in cubit. These properties
 * have default names, which will be listed below.
 * <ul>
 *  <li> termination.cell </li>
 *  <li> reflecting.surface </li>
 *  <li> material_\#_density_# </li>
 *  <li> material_\#_density_-# </li>
 *  <li> estimator_#.surface.current.n </li>
 *  <li> estimator_#.surface.current.p </li>
 *  <li> estimator_#.surface.current.e </li>
 *  <li> estimator_#.surface.flux.n </li>
 *  <li> estimator_#.surface.flux.p </li>
 *  <li> estimator_#.surface.flux.e </li>
 *  <li> estimator_#.cell.pulse.height.p </li>
 *  <li> estimator_#.cell.pulse.height.e </li>
 *  <li> estimator_#.cell.pulse.height.pe </li>
 *  <li> estimator_#.cell.tl.flux.n </li>
 *  <li> estimator_#.cell.tl.flux.p </li>
 *  <li> estimator_#.cell.tl.flux.e </li>
 *  <li> estimator_#.cell.c.flux.n </li>
 *  <li> estimator_#.cell.c.flux.p </li>
 *  <li> estimator_#.cell.c.flux.e </li>
 * </ul>
 * The termination.cell, reflecting.surface, material, density, estimator, 
 * surface.current, surface.flux, cell.pulse.height, cell.tl.flux, 
 * cell.c.flux keywords can all be substituted with any alternative of your 
 * choosing (these alternatives must be specified in the 
 * \ref geometry_xml_file "geometry xml file"). 
 *
 * The final step is to export the geometry. Attributes must be set to on
 * to save absolute volumes, surface ids and the group specifications. This
 * is done with the following command:
 * \code{.unparsed}
 * set attribute on
 * \endcode
 * The geometry must be exported as an ACIS (.sat) file. If the CUBIT version
 * is greater than 12.x, set the ACIS geometry back to version 19:
 * \code{.unparsed}
 * set geom version 1900
 * \endcode
 * Use the file pull-down menu to export the geometry.
 *
 * \subsection geometry_xml_file Creating the Geometry XML file
 * The geometry XML file is set up so that it can be read into a 
 * Teuchos::ParameterList object internally. The only XML elements allowed
 * are "ParameterList" and "Parameter". The "ParameterList" element only
 * has one allowed attribute called "name". The "Parameter" element has
 * three allowed attributes: "name", "type", and "value".
 *
 * Three parameter elements must appear in every geometry file. The first
 * is the handler element, which specifies the geometry handler that will be
 * used by FACEMC. The second is the
 * CAD file that FACEMC will use. The third is the face tolerance that 
 * DAGMC will use to facet the CAD geometry. A basic geometry file is
 * shown below.
 * \code
 * <ParameterList name="Geometry">
 *
 * <Parameter name="Handler" type="string" value="DagMC"/>
 * <Parameter name="CAD File" type="string" value="water_sphere2.sat"/>
 * <Parameter name="Facet Tolerance" type="double" value="1e-3"/>
 * 
 * </ParameterList>
 * \endcode
 *
 * If different CUBIT keywords were chosen, they must be specified in the
 * XML file as well:
 * \code
 * <ParameterList name="Geometry">
 *
 * <Parameter name="Handler" type="string" value="DagMC"/>
 * <Parameter name="CAD File" type="string" value="my_cad_geom.sat"/>
 * <Parameter name="Facet Tolerance" type="double" value="1e-3"/>
 *
 * <Parameter name="Use Fast Id Lookup" type="bool" value="True"/>
 *
 * <Parameter name="Termination Cell Property" type="string" value="termination.cell"/>
 * <Parameter name="Reflecting Surface Property" type="string" value="spec.reflect"/>
 * <Parameter name="Material Property" type="string" value="mat"/>
 * <Parameter name="Density Property" type="string" value="rho"/>
 * <Parameter name="Estimator Property" type="string" value="estimator"/>
 *
 * <Parameter name="Surface Current Name" type="string" value="surface.current"/>
 * <Parameter name="Surface Flux Name" type="string" value="surface.flux"/>
 * <Parameter name="Cell Pulse Height Name" type="string" value="cell.pulse.height"/>
 * <Parameter name="Cell Track-Length Flux Name" type="string" value="cell.tl.flux"/>
 * <Parameter name="Cell Collision Flux Name" type="string" value="cell.c.flux"/>
 * 
 * </ParameterList>
 * \endcode
 * Please note that keyword properties and estimator names may not use the 
 * underscore ("_") character as this is a reserved character in DagMC.
 *
 * The above input file also includes an option called "Use Fast Id Lookup".
 * The option causes DagMC to use a different method for looking up cell and
 * surface ids that can often increase performance. The memory overhead will
 * increase when this option is turned on so it should not be used with large
 * problems. 
 *
 * \section geometry_sec_root Geometry Construction - ROOT
 * In order to use Root as the geometry handler for a simulation, a Root
 * geometry must be utilized. The geometry must be constructed according to
 * Root standards, and must be exported to a binary file prior to being used
 * for a simulation. While this section will provide a brief overview of using
 * ROOT with FRENSIE, for more in depth topics consult the
 * <a href="ftp://root.cern.ch/root/doc/18Geometry.pdf">ROOT Geometry Handbook</a>.
 *
 * \subsection root_workflow ROOT Workflow
 * 
 * Workflow in ROOT is quite straightforward. In order to construct a ROOT
 * geometry for particle tracking, the following workflow should be followed:
 *
 * <ol>
 *  <li> Construct a standard C file containing the ROOT geometry via a
         collection of volumes (discrete and combined), all embedded within a graveyard volume.</li>
 *   <ul><li> Each volume must have an assigned material and density</li>
 *       <li> Each volume must have an unique user-specified identifer 
 *            assigned</li></ul>
 *  <li> Ensure that overlapping regions of sister volumes are properly 
 *       assigned</li>
 *  <li> Ensure that daughter volumes are assigned to a parent, starting from 
 *       the bottom node</li>
 *  <li> Visualize the geometry</li>
 *  <li> Export to binary format for use in FRENSIE</li>
 * </ol>     
 *
 * \subsection root_std_c Constructing ROOT Geometries
 *
 * An input file for ROOT is a C style file whose contained class 
 * <b>must</b> match the name of the file itself. For example, if an input file
 * is named <b>root_input.C</b>, then the geometry definition will be contained
 * within a class named <b>root_input()</b>. Once the class has been
 * constructed, the first function call must always be to load the ROOT
 * geometry library. This can be done with the following function call:
 *
 * \code{.c}
 * gSystem->Load("libGeom");
 * \endcode
 *
 * The second function call must always be to generate a geometry manager which
 * will handle the specific world contained in this geometry file. This is done
 * by creating a 
 * <a href="https://root.cern.ch/root/html/TGeoManager.html"> TGeoManager</a>
 * by passing in a name and description for the geometry. See the following
 * function call
 *
 * \code{.c}
 * new TGeoManager( "Geometry_Name", "Geometry_Description" );
 * \endcode
 *
 * Combining all of this, an initial skeleton code for a ROOT input file named
 * <b>root_input.C</b> would take the form:
 *
 * \code{.c}
 * void root_input()
 * {
 *   // Load the geometry library and initialize the geometry handler
 *   gSystem->Load("libGeom");
 *   new TGeoManager( "Geometry_Name", "Geometry_Description" );
 * } 
 * \endcode
 *
 * In order to define an actual geometry, one must first understand that ROOT is
 * an atypical combinatorial geometry (CG) package. In most CG packages, such
 * as that found in MCNP, a user defines a series of surfaces, from which they
 * define cells which are bounded by various combinations of those surfaces.
 * However, in ROOT a user defines a set of volumes, which are a combination of
 * a closed three-dimensional shape, and a filling medium. 
 *
 * \subsubsection root_material ROOT Material Generation 
 *
 * The first step in geometry creation is to define the materials that will be
 * used in the problem. These materials will be used to construct various media
 * which are needed by ROOT to fill volumes. For the purposes of FRENSIE, the
 * importance of the medium class can be ignored, but if the user wishes to
 * see a description of its origins (GEANT3), see the
 * <a href="ftp://root.cern.ch/root/doc/18Geometry.pdf">ROOT Geometry Handbook</a> 
 * (pg. 302).
 *
 * The <a href="https://root.cern.ch/root/html/TGeoMaterial.html"> TGeoMaterial</a> 
 * class is used to construct an elemental material in ROOT. There is also
 * a <a href="https://root.cern.ch/root/html/TGeoMixture.html"> TGeoMixture</a>
 * class that is derived from the TGeoMaterial class, which is used to
 * construct a material made of many elements. FRENSIE only cares about the
 * material name and the material density so the TGeoMixture class never
 * needs to be used. In fact, it should <b>never</b> be used since it does
 * not accept a negative density, which will be used to denote a mass
 * density.
 *
 * For an elemental material, one must provide a name to the material, 
 * the mass number, the atomic number, and the density. Again, the mass
 * number and atomic number will be ignored by FRENSIE so any values can be
 * used. There are several material names that are recognized by FRENSIE. These
 * material names have the following defaults:
 *
 * <ul>
 *  <li>mat_#</li>
 *  <li>void</li>
 *  <li>graveyard</li>
 * </ul>
 *
 * If a material is assigned a name of "mat_#" then the cell will contain
 * the material definition associated with material "#" (defined in the 
 * material xml file). If a material is assigned the name of "void" the cell
 * will contain no material but particle transport will still be
 * done on it. Assigning a material name of "graveyard" indicates to 
 * FRENSIE that any particle entering this cell should be terminated. 
 * The mat, void and graveyard keywords can all be substituted with any
 * alternative of your choosing (these alternatives must be specified in the
 * \ref root_xml_example "root xml file"). 
 * 
 * When specifying the density, note that a positive value for the
 * density denotes atomic density (atoms/b-cm), while a negative value denotes 
 * a mass density (g/cm^3). The example below defines a material with id 1
 * and a density of 0.001 g/cm^3.
 *
 * \code{.c}
 * // Material Definition Form:
 * // TGeoMaterial( "name", A, Z, Density )
 *
 * // Elemental Hydrogen ( rho = 0.001 g/cm^3 )
 * TGeoMaterial* H = new TGeoMaterial( "mat_1", 1, 1, -0.001 );
 * \endcode
 *
 * The final step before proceeding to volume creation is to create a 
 * corresponding
 * <a href="https://root.cern.ch/root/html/TGeoMedium.html"> TGeoMedium</a> for
 * each material that has been defined. To define a medium, the user 
 * must provide a name, a medium index, and a material. By convention
 * the name should be "med_#" where the number matches that of the material to 
 * which it corresponds. Make sure that each medium has a unique index. The 
 * following example shows the medium definition of hydrogen assuming the 
 * material is defined as in the previous example.
 *
 * \code{.c}
 * // Medium Definition Form:
 * // TGeoMedium( "name", Index, TGeoMaterial (or TGeoMixture) )
 * 
 * // Medium for Pure Hydrogen
 * TGeoMedium* H_medium = new TGeoMedium( "med_1", 0, H );
 * \endcode
 *
 * \subsubsection root_volume ROOT Volume Generation 
 * 
 * Once the materials and media have been defined, volumes construction can
 * proceed. There are various types of predefined shapes in ROOT, all of which
 * are discussed in the 
 * <a href="ftp://root.cern.ch/root/doc/18Geometry.pdf">ROOT Geometry Handbook</a> 
 * (pg. 306). A volume in ROOT consists of a shape which has been filled with
 * a medium. While one can construct a shape separately and then form a volume,
 * for simple volumes it is often easier to use predefined functions which allow
 * for direct volume creation. The following simple volumes can be constructed
 * directly from the geometry manager:
 *
 * <ul>
 *   <li><b>Right Parallelepiped</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeBox"> MakeBox</a>) </li>
 *   <li><b>Sphere</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeSphere"> MakeSphere</a>) </li>
 *   <li><b>Cylinder or Tube</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeTube"> MakeTube</a>) </li>
 *   <li><b>Cone</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeCone"> MakeCone</a>) </li>
 *   <li><b>Trapezoidal Volumes</b></li>
 *   <ul>
 *     <li>(<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeTrd1"> MakeTrd1</a>)</li>
 *     <li>(<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeTrd2"> MakeTrd2</a>)</li>
 *     <li>(<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeTrap"> MakeTrap</a>)</li>
 *   </ul>
 *   <li><b>Torus</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeTorus"> MakeTorus</a>) </li>
 *   <li><b>Paraboloid</b> - (<a href="https://root.cern.ch/root/html/TGeoManager.html#TGeoManager:MakeParaboloid"> MakeParaboloid</a>) </li>
 *   <li>See the handbook for the full list of volumes that can be created...</li>
 * </ul>
 * 
 * The simple example of constructing a sphere of hydrogen is shown below, 
 * assuming the hydrogen medium is defined from the previous section.
 *
 * \code{.c}
 * // Sphere Definition Form:
 * // MakeSphere( "name", TGeoMedium, Minimum_Radius, Maximum_Radius )
 *
 * // Sphere of Hydrogen of radius 1.0cm centered at (0,0,0)
 * TGeoVolume *H_Sphere = gGeoManager->MakeSphere( "Hydrogen_Sphere", H_medium, 0.0, 1.0 );
 * \endcode
 *
 * It should be noted that most volumes (Box, Sphere, Torus, etc.) are centered
 * about the point (0,0,0). The next section on heirarchy will explore 
 * the movement (translation and rotation) of volumes in space. The final thing
 * that <b>must</b> be done, is to assign a unique identifier to each volume.
 * This is so that when estimators and materials are assigned in the XML input
 * files for FRENSIE, they are mapped to the correct volume entity. Note that
 * all unique identifiers must be positive, and each volume must have its own
 * unique identifier.
 *
 * \code{.c}
 * H_Sphere->SetUniqueID(1);
 * \endcode
 *
 * \subsubsection root_heirarchy ROOT Volume Heirarchy and Positioning 
 *
 * In ROOT, the heirarchy between various volumes must be explicitly stated by
 * defining relationships between volumes which overlap, and those which are 
 * completely contained within another volume. The simplest case is when a
 * volume is completely contained within another volume. In this case there is a
 * daughter and parent volume. For example, the sphere of water we defined is
 * now sitting in an a box of side length 3cm. Therefore, if no heirarchy is
 * defined, the region which the sphere occupies is also occupied by the cube,
 * and ROOT cannot determine what volume owns that space. In order to clarify
 * we need to state that the water sphere is now a daughter of the box. This
 * can be done by using the AddNode() function call.
 *
 * \code{.c}
 * // Assume that H_Sphere defines a sphere of hydrogen of radius 1.0cm 
 * // and Air_Cube defines a cube of air of side length 3.0cm both centered
 * // at (0,0,0).
 *
 * // AddNode Definition Form:
 * // AddNode( Daughter_Node, Copy_Number )
 *
 * Air_Cube->AddNode( H_Sphere, 1 );
 * \endcode
 *
 * Taking this one step further, perhaps the user would like to offset the
 * sphere, such that it still remains within the box but is translated by 
 * (0.25cm,0.25cm,0.25cm). This can be done by utilizing an optional input
 * parameter on the AddNode() function, which allows for a translation
 * matrix to be utilized.
 *
 * \code{.c}
 * Air_Cube->AddNode( H_Sphere, 1, new TGeoTranslation(0.25,0.25,0.25) );
 * \endcode
 *
 * The final issue to take into account would be overlapping regions. These
 * become significantly more complicated and require the user to deal with them
 * carefully. If two volumes at the same heirarchy level overlap, the 
 * AddNodeOverlap() function must be used. However, one must keep the following
 * points in mind:
 *
 * <ol>
 *  <li> Overlapping regions are owned by all volumes in which they reside</li>
 *  <li> The geometry handler will assign priority ownership to the volume 
 *       which was <b>not</b> defined as overlapping
 *  <li> In the event the user fails to specify overlap, the volume which was 
 *       defined first will assume priority ownership of the region</li>
 * </ol> 
 *
 * For a simple example, imagine two spheres, Sphere_Left and Sphere_Right 
 * which overlap each other. If the user wishes to have Sphere_Left own the
 * region of overlap, the appropriate function call would be:
 *
 * \code{.c}
 * Sphere_Right->AddNodeOverlap( Sphere_Left, 1 );
 * \endcode
 *
 * This function call has stated that Sphere_Right has an overlapping region
 * with Sphere_Left. This leaves Sphere_Left in a "non-overlapping" state.
 * Therefore, in the region where both spheres overlap, the geometry handler
 * will see that Sphere_Right was defined as overlapping, where Sphere_Left was
 * not, and thus assign priority ownership to Sphere_Left. This is by far the
 * most cumbersome component to geometry manipulation in ROOT, and requires 
 * great care on the part of the user.
 *
 * \subsubsection Geometry Visualization and Export
 *
 * The final step in creating a ROOT geometry is to visualize the geometry, and
 * then once satisfied (and ROOT does not throw any errors) to export it to
 * a binary which can be read by FRENSIE.
 *
 * When constructing the geometry, one must also include a volume which 
 * contains all other volumes. This volume will be the graveyard volume, or 
 * the rest of universe region. Note that the material in this volume should be
 * assigned a material name of "graveyard" (or the user specified replacement),
 * so that it can be identified by FRENSIE. One must also set this volume as 
 * the Top volume using the function call SetTopVolume:
 *
 * \code{.c}
 * gGeoManager->SetTopVolume( Graveyard );
 * \endcode
 *
 * Once this has been done the geometry can be closed as follows:
 *
 * \code{.c}
 * gGeoManager->CloseGeometry( Graveyard );
 * \endcode
 *
 * The geometry can then be visualized using the functions:
 *
 * \code{.c}
 * gGeoManager->SetTopVisible();
 * Graveyard->Draw(); // Where Graveyard is the name of the top volume
 * \endcode
 *
 * Finally, the geometry can be exported to a binary file via the function:
 *
 * \code{.c}
 * gGeoManager->Export( "output_file_name.root" );
 * \endcode
 *
 * \subsubsection root_xml_example ROOT Geometry File
 *
 * The following is a very simple example ROOT geometry file. It consists of a
 * 1cm radius sphere of hydrogen, inside of a void cube of side length 3cm, all
 * contained within a graveyard cube of side length 4cm. 
 *
 * \code{.c}
 * //---------------------------------------------------------------------------//
 * //!
 * //! \file   Verification_Test.C
 * //! \author Eli Moll
 * //! \brief  Geometry for verification testing on ROOT implementation
 * //!
 * //---------------------------------------------------------------------------//
 * 
 * //  Description: A verification study geometry file for comparison between
 * //  ROOT and DagMC using FRENSIE. Hydrogen at 2500k in a 1cm sphere is
 * //  surrounded by void. A surface current tally and cell track-length flux
 * //  tally are placed on the sphere.
 *  
 * void Verification_Test()
 * {
 *   // Set up manager of geometry world
 *   gSystem->Load( "libGeom" );
 *   new TGeoManager( "Verification_Geometry",
 *                    "Geometry for verifying root implementation" );
 * 
 * //---------------------------------------------------------------------------//
 * // Material Definitions
 * //---------------------------------------------------------------------------//
 * 
 *   // Hydrogen
 *   TGeoMaterial *mat_1 = new TGeoMaterial( "mat_1",1,1,1 );
 *   TGeoMedium   *med_1 = new TGeoMedium( "med_1",2,mat_1 );
 * 
 *   // Void
 *   TGeoMaterial *void_mat = new TGeoMaterial( "void",0,0,0 );
 *   TGeoMedium   *void_med = new TGeoMedium( "void_med",1,void_mat );
 * 
 *   // Graveyard (terminal)
 *   TGeoMaterial *terminal_mat = new TGeoMaterial( "graveyard",0,0,0 );
 *   TGeoMedium   *terminal_med = new TGeoMedium( "graveyard",3,terminal_mat );
 * 
 * //---------------------------------------------------------------------------//
 * // Volume Definitions
 * //---------------------------------------------------------------------------//
 * 
 *   // Graveyard Volume
 *   TGeoVolume *terminal_cube = gGeoManager->MakeBox( "TERMINAL",
 *                                                      terminal_med,
 *                                                      2.0, 2.0, 2.0 );
 *   terminal_cube->SetUniqueID(3);   
 *                                                      
 *   // Set the graveyard to be the top volume (rest-of-universe)
 *   gGeoManager->SetTopVolume( terminal_cube );
 * 
 *   // Void Volume (cube)
 *   TGeoVolume *cube = gGeoManager->MakeBox( "CUBE",
 *                                            void_med, 
 *                                            1.5, 1.5, 1.5 );
 *   cube->SetUniqueID(2);
 * 
 *   // Hydrogen Volume (sphere)
 *   TGeoVolume *sphere = gGeoManager->MakeSphere( "SPHERE",
 *                                                 med_1,
 *                                                 0.0,1.0 );
 *   sphere->SetUniqueID(1);
 * 
 * //---------------------------------------------------------------------------//
 * // Heirarchy (Volume) Definitions
 * //---------------------------------------------------------------------------//
 * 
 *   // Add SPHERE as a daughter of CUBE
 *   terminal_cube->AddNode( cube, 1 );
 *   
 *   // Add CUBE as a daughter of TERMINAL
 *   cube->AddNode( sphere, 1 );
 * 
 * //---------------------------------------------------------------------------//
 * // Export and Drawing Capabilities
 * //---------------------------------------------------------------------------//
 * 
 *   // Close the geometry
 *   gGeoManager->CloseGeometry();
 *   gGeoManager->SetTopVisible();
 *   
 *   // Uncomment to draw the geometry in an X-Window
 *   terminal_cube->Draw();
 *   
 *   gGeoManager->Export("overlap_study.root");
 * 
 * }  // end Test_Root_Geometry
 * 
 * //---------------------------------------------------------------------------//
 * // end Test_Root_Geometry.C
 * //---------------------------------------------------------------------------//
 * \endcode
 *
 * \subsection root_geom_xml Creating the Geometry XML File
 *
 * The ROOT geometry XML file only requires two parameters, which are the 
 * geometry handler and the name of the ROOT binary geometry file. A basic
 * geometry file is shown below.
 *
 * \code
 * <ParameterList name="Geometry">
 *
 * <Parameter name="Handler" type="string" value="ROOT"/>
 * <Parameter name="Root File" type="string" value="geometry_file.root"/>
 * 
 * </ParameterList>
 * \endcode
 *
 * If different material keywords were chosen, they must be specified in the
 * XML file as well:
 *
 * \code
 * <ParameterList name="Geometry">
 *
 * <Parameter name="Handler" type="string" value="ROOT"/>
 * <Parameter name="Root File" type="string" value="geometry_file.root"/>
 * 
 * <Parameter name="Void Material Name" type="string" value="empty"/>
 * <Parameter name="Terminal Material Name" type="string" value="killzone"/>
 * <Parameter name="Material Property Name" type="string" value="material"/>
 * 
 * </ParameterList>
 * \endcode
 *
 * \section cross_section_dir Cross Section Directory
 * Before discussing how materials are specified, the layout of the directory
 * containing the cross section tables must be discussed.
 * The cross section directory must contain all of the cross section tables
 * that will be used in the simulation. It can be set up in a very similar
 * fashion to the MCNP_DATA directory used by MCNP. In this directory, an
 * XML file must be created called "cross_sections.xml", which is very similar
 * to the xsdir file used by MCNP. The file will have the following form:
 * \code
 * <ParameterList name="cross sections">
 * 
 * <ParameterList name="alias map">
 *   <Parameter name="1001" type="string" value="H-1_293.6K"/>
 *   <Parameter name="8016" type="string" value="O-16_293.6K"/>
 *   <Parameter name="H-1" type="string" value="H-1_239.6K"/>
 *   <Parameter name="O-16" type="string" value="O-16_239.6K"/>
 * </ParameterList>
 * 
 * <ParameterList name="H-1_293.6K">
 *   <Parameter name="nuclear_file_path" type="string" value="endf70a"/>
 *   <Parameter name="nuclear_file_type" type="string" value="ACE"/>
 *   <Parameter name="nuclear_file_start_line" type="int" value="1"/>
 *   <Parameter name="nuclear_table_name" type="string" value="1001.70c"/>
 *   <Parameter name="photoatomic_file_path" type="string" value="mcplib12"/>
 *   <Parameter name="photoatomic_file_type" type="string" value="ACE"/>
 *   <Parameter name="photoatomic_file_start_line" type="int" value="1"/>
 *   <Parameter name="photoatomic_table_name" type="string" value="1000.12p"/>
 *   <Parameter name="electroatomic_file_path" type="string" value="mcplib12"/>
 *   <Parameter name="electroatomic_file_type" type="string" value="ACE"/>
 *   <Parameter name="electroatomic_file_start_line" type="int" value="1"/>
 *   <Parameter name="electroatomic_table_name" type="string" value="1000.12p"/>
 *   <Parameter name="temperature" type="double" value="2.53010e-08"/>
 *   <Parameter name="atomic_weight_ratio" type="double" value="0.999167"/>
 *   <Parameter name="atomic_number" type="int" value="1"/>
 *   <Parameter name="atomic_mass_number" type="int" value="1"/>
 *   <Parameter name="isomer_number" type="int" value="0"/>
 * </ParameterList>
 *
 * <ParameterList name="O-16_293.6K">
 *   <Parameter name="nuclear_file_path" type="string" value="endf70a"/>
 *   <Parameter name="nuclear_file_type" type="string" value="ACE"/>
 *   <Parameter name="nuclear_file_start_line" type="int" value="1428717"/>
 *   <Parameter name="nuclear_table_name" type="string" value="8016.70c"/>
 *   <Parameter name="photoatomic_file_path" type="string" value="mcplib12"/>
 *   <Parameter name="photoatomic_file_type" type="string" value="ACE"/>
 *   <Parameter name="photoatomic_file_start_line" type="int" value="31405"/>
 *   <Parameter name="photoatomic_table_name" type="string" value="8000.12p"/>
 *   <Parameter name="electroatomic_file_path" type="string" value="mcplib12"/>
 *   <Parameter name="electroatomic_file_type" type="string" value="ACE"/>
 *   <Parameter name="electroatomic_file_start_line" type="int" value="31405"/>
 *   <Parameter name="electroatomic_table_name" type="string" value="8000.12p"/>
 *   <Parameter name="temperature" type="double" value="2.53010e-08"/>
 *   <Parameter name="atomic_weight_ratio" type="double" value="15.857510"/>
 *   <Parameter name="atomic_number" type="int" value="8"/>
 *   <Parameter name="atomic_mass_number" type="int" value="16"/>
 *   <Parameter name="isomer_number" type="int" value="0"/>
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode
 * Note that each isotope will have an alias that will be used to refer to it
 * (as apposed to a zaid number). There is also a set of alternative aliases in
 * the "alias map" that can be used instead of the default aliases.
 *
 * \section creating_material_xml_file Creating the Material XML file
 * Three parameter elements must appear in every material file. The first
 * is the material id. Note that any material id specified in the geometry file
 * must have a corresponding material definition in this XML file. The second 
 * is the fractions element, which is used to specify the atom or weight 
 * fractions of each isotope in the material. To specify weight fractions, 
 * negative numbers should be given. Also note that the fractions need not be 
 * normalized - this will be done internally. The third parameter is the 
 * isotopes element, which is used to specify the isotopes in the material.
 * A valid alias (specified in the cross_sections.xml file) must be used
 * to refer to an isotope. A material XML file that could be used to specify
 * water is given below.
 * \code
 * <ParameterList name="Materials">
 *
 * <ParameterList name="H Sphere">
 * <Parameter name="Id" type="unsigned int" value="1"/>
 * <Parameter name="Fractions" type="Array" value="{1.0,2.0}"/>
 * <Parameter name="Isotopes" type="Array(string)" value="{O-16_293.6K, H-1_293.6K}"/>
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * A helpful reference for determining appropriate weight fractions of many
 * known mixtures (especially those common in nuclear engineering) is the 
 * <a href="http://www.pnnl.gov/main/publications/external/technical_reports/PNNL-15870Rev1.pdf"> 
 * PNNL Compendium of Material Composition Data for Radiation Transport 
 * Modeling</a>.
 *
 * \section one_d_distributions One-Dimensional Distributions
 * Before discussing the remaining XML files, a special parameter type must
 * be discussed: the one-dimensional distribution. one-dimensional
 * distributions can be used to represent a sampling distribution or a
 * weighting distribution. Each distribution and a corresponding example 
 * parameter element will be shown below.
 *
 * <ul>
 *  <li><b>Delta distribution</b>
 *   <ul>
 *    <li>\code
 *        <Parameter name="example" type="Delta Distribution" value="{0}"/>
 *        <Parameter name="example" type="Delta Distribution" value="{0,0.5}"/>
 *        \endcode</li>
 *    <li>Models a delta function \f$c\delta(x-a)\f$ or single point.</li>
 *    <li>Should almost exclusively be used for sampling purposes.</li>
 *    <li>The value attribute specifies the \f$a\f$ value of the delta 
 *        distribution and the constant multiplier \f$c\f$ (optional). 
 *        </li></ul></li>
 *  <li><b>Discrete distribution</b>
 *   <ul>
 *    <li>\code
 *        <Parameter name="example a" type="Discrete Distribution" value="{{-1.0, 0.0, 1.0},{1.0, 2.0, 1.0}}"/>
 *        <Parameter name="example b" type="Discrete Distribution" value="{{-1.0, 3i, 1.0},{0.25, 0.5, 1.0, 0.5, 0.25}}"/>
 *        <Parameter name="example c" type="Discrete Distribution" value="{{1e-4, 3l, 1.0},{1.0, 3i, 1.0}}"/>
 *        \endcode</li>
 *    <li>Models a sum of delta functions \f$\sum_i c_i\delta(x-a_i)\f$ or 
 *        series of points with associated weights</li>
 *    <li>Should almost exclusively be used for sampling purposes</li>
 *    <li><b>Note:</b> When treated as a sampling distribution it is acceptable
 *        to have repeated points</li>
 *    <li>The value attribute specifies the array of points (\f$a_i\f$) and the
 *        array of point weights (\f$c_i\f$).</li>
 *    <li>For sampling distributions, the array of weights will be 
 *        normalized.</li>
 *    <li>The weights should always be positive.</li>
 *    <li>\ref interval_operators "Interval operators" can be used when 
 *        specifying this distribution.</li></ul></li>
 *   <li><b>Exponential distribution</b>
 *    <ul>
 *     <li>\code
 *         <Parameter name="example a" type="Exponential Distribution" value="{2}"/>
 *         <Parameter name="example b" type="Exponential Distribution" value="{2,3}"/>
 *         <Parameter name="example c" type="Exponential Distribution" value="{2,3,1}"/>
 *         <Parameter name="example d" type="Exponential Distribution" value="{2,3,1,10}"/>
 *
 *          \endcode</li>
 *     <li>Models an exponentially decaying function 
 *         \f$b*\exp(-a*x), x \in [c,d]\f$</li>
 *     <li>The value attribute specifies the decay consant \f$a\f$, which
 *         should always be positive, the constant multiplier \f$b\f$ 
 *         (optional), the lower bound of the independent variable
 *         \f$c\f$ (optional), which must be greater than or equal to zero, and
 *         the upper bound of the independent variable \f$d\f$ (optional).</li>
 *     <li>The default value of \f$b\f$ is 1.0.</li>
 *     <li>The default value of \f$c\f$ is 0.0.</li>
 *     <li>The default value of \f$d\f$ is inf.</li>
 *     <li>For sampling distributions, the \f$b\f$ value will be
 *         replaced by a normalization constant.</li></ul></li>
 *   <li><b>Histogram distribution</b>
 *    <ul>
 *     <li>\code
 *         <Parameter name="example a" type="Histogram Distribution" value="{{-2.0, -1.0, 1.0, 2.0},{2.0, 1.0, 2.0}}"/>
 *         <Parameter name="example b" type="Histogram Distribution" value="{{-2.0, 3i, 2.0},{2.0, 1.0, 1.0, 2.0}}"/>
 *         <Parameter name="example c" type="Histogram Distribution" value="{{1e-4, 3l, 1.0},{1.0, 2i, 1.0}}"/>
 *         \endcode</li>
 *      <li>The value attribute specifies the \f$n\f$ histogram
 *          bin boundaries and the \f$n-1\f$ bin values.</li>
 *      <li>For sampling distributions, the bin values will be normalized. Bin 
 *          values should always be positive.</li>
 *    <li>\ref interval_operators "Interval operators" can be used when 
 *        specifying this distribution.</li></ul></li>
 *   <li><b>Evaporation distribution</b>
 *    <ul>
 *     <li>\code
 *         <Parameter name="example a" type="Evaporation Distribution" value="{1.0,1.0,0.1}"/>
 *         <Parameter name="example b" type="Evaporation Distribution" value="{3.0,2.0,1.0}"/>
 *         <Parameter name="example c" type="Evaporation Distribution" value="{1.0,1.0,0.0}"/>
 *         <Parameter name="example d" type="Evaporation Distribution" value="{1.0,1.0,0.0,0.5}"/>
 *         \endcode</li>
 *     <li> Models an evaporation distribution \f$cxe^{-x/T(E_{in})}\f$ for 
 *          \f$x \in [0,E_{in}-U]\f$.</li>
 *     <li>The value attribute specifies the incident energy \f$E_{in}\f$, 
 *         the nuclear temperature \f$T(E_{in})\f$, the restriction energy 
 *         \f$U\f$, and the constant multiplier \f$c\f$ (optional).</li>
 *     <li>The incident neutron energy \f$E_{in}\f$ and nuclear temperature 
 *         \f$T(E_{in})\f$ must be strictly positive.</li>
 *     <li>The default values are 1.0 for \f$E_{in}\f$, 1.0 for 
 *         \f$T(E_{in})\f$, 0.0 for \f$U\f$, and 1.0 for \f$c\f$.</li>
 *     <li>For sampling distributions the constant multiplier \f$c\f$ will be 
 *         replaced with \f$C^{-1}=T^{2}[1-e^{-(E_{in}-U)/T}(1+(E_{in}-U)/T)]\f$.</li></ul></li> 
 *   <li><b>Maxwell Fission distribution</b>
 *    <ul>
 *     <li>\code
 *         <Parameter name="example a" type="Maxwell Fission Distribution" value="{1.0,1.0,0.1}"/>
 *         <Parameter name="example b" type="Maxwell Fission Distribution" value="{3.0,2.0,1.0}"/>
 *         <Parameter name="example c" type="Maxwell Fission Distribution" value="{1.0,1.0,0.0}"/>
 *         <Parameter name="example d" type="Maxwell Fission Distribution" value="{1.0,1.0,0.0,0.5}"/>
 *         \endcode</li>
 *     <li>Models a Maxwell fission spectrum \f$c\sqrt{x}e^{-x/T(E_{in})}\f$ 
 *         for \f$x \in [0,E_{in}-U]\f$.</li>
 *     <li>The value attribute specifies the incident energy \f$E_{in}\f$, the 
 *         nuclear temperature \f$T(E_{in})\f$, the restriction energy \f$U\f$,
 *         and the constant multiplier \f$c\f$ (optional).</li>
 *     <li>The incident neutron energy and nuclear temperature must be strictly
 *         positive.</li>
 *     <li>The default values are 1.0 for \f$E_{in}\f$, 1.0 for 
 *         \f$T(E_{in})\f$, 0.0 for \f$U\f$ and 1.0 for \f$c\f$.</li>
 *     <li>For sampling distributions the constant multiplier \f$c\f$ will be
 *         replaced with \f$C^{-1}=T^{3/2}[(\frac{\sqrt{\pi}}{2})erf(\sqrt{\frac{E_{in}-U}{T}})-\sqrt{\frac{E_{in}-U}{T}}e^{-(E_{in}-U)/T}]\f$.</li></ul></li>
 *   <li><b>Watt distribution</b>
 *    <ul>
 *     <li>\code
 *         <Parameter name="example a" type="Watt Distribution" value="{1.0,1.0,1.0,0.1}"/>
 *         <Parameter name="example b" type="Watt Distribution" value="{3.0,2.0,1.0,0.0}"/>
 *         <Parameter name="example c" type="Watt Distribution" value="{3.0,2.0,1.0,0.0,0.5}"/>
 *         \endcode</li>
 *     <li>Models a Watt spectrum \f$ce^{-x/a(E_{in})}sinh\sqrt{b(E_{in})x}\f$
 *         for \f$x \in [0,E_{in}-U]\f$.</li>
 *     <li>The value attribute specifies the incident energy \f$E_{in}\f$, the 
 *         isotope and energy dependent paramters \f$a\f$ and \f$b\f$, the 
 *         restriction energy \f$U\f$, and the constant multiplier \f$c\f$
 *         (optional).</li>
 *     <li>The incident neutron energy and nuclear temperature must
 *         be strictly positive.</li>
 *     <li>The default values are 1.0 for \f$E_{in}\f$, 1.0 for \f$a\f$, 1.0 
 *         for \f$b\f$, 0.0 for \f$U\f$, and 1.0 for \f$c\f$.</li>
 *     <li>For sampling distributions the constant multiplier c will be 
 *         replaced with \f$C^{-1}=\frac{1}{2}\sqrt{\frac{\pi a^{3}b}{4}}exp(\frac{ab}{4})[erf(\sqrt{\frac{E_{in}-U}{a}}-\sqrt{\frac{ab}{4}})+erf(\sqrt{\frac{E_{in}-U}{a}}+\sqrt{\frac{ab}{4}})]-aexp[-\frac{E_{in}-U}{a}]sinh\sqrt{b(E_{in}-U)}\f$.</li></ul></li>
 *    <li><b>Normal distribution</b>
 *     <ul>
 *      <li>\code
 *          <Parameter name="example a" type="Normal Distribution" value="{0,1,-inf,inf}"/>
 *          <Parameter name="example b" type="Normal Distribution" value="{0,1}"/>
 *          <Parameter name="example c" type="Normal Distribution" value="{1.5,0.25,-10,10}"/>
 *          <Parameter name="example a" type="Normal Distribution" value="{0,1,-inf,inf,0.5}"/>
 *          \endcode</li>
 *      <li>Models a Gaussian function \f$c\exp{-\frac{(x-\mu)^2}{2\sigma^2}}\f$ for \f$x \in [a,b]\f$</li>
 *      <li>The value attribute specifies the mean \f$\mu\f$, standard
 *          deviation \f$\sigma\f$ (must be strictly greater than zero), the
 *          lower bound of the independent variable \f$a\f$ (optional), the
 *          upper bound of the independent variable \f$b\f$ (optional) and the
 *          constant multiplier \f$c\f$ (optional).
 *      <li>The special values of "-inf" and "inf" can be used
 *          for the bounds to essentially provide no cutoff values (these
 *          are the default values).</li>
 *      <li>The default multiplier \f$c\f$ is 1.0. For sampling distributions
 *          this value will be replaced by 
 *          \f$\frac{1.0}{\sigma \sqrt{2\pi}}\f$.</li></ul></li>
 *    <li><b>Polynomial Distribution</b>
 *     <ul>
 *      <li>\code
 *          <Parameter name="example" type="Polynomial Distribution" value="{{1.00000000000000000e+00, 2.00000000000000000e+00, 3.00000000000000000e+00},0,1}"/>
 *          \endcode</li>
 *      <li>Models the polynomial function \f$\sum_{i=0}^{N-1} c_ix_i\f$ for
 *          \f$x \in [a,b]\f$</li>
 *      <li>The value attribute specifies the array of polynomial coefficients 
 *          \f$c_i\f$, the minimum \f$x\f$ value \f$a\f$ and the maximum
 *          \f$x\f$ value \f$b\f$ respectively. For the values to be valid
 *          every term in the series must be strictly positive over the 
 *          desired range.
 *      <li>These distributions are sampled directly using a combination of
 *          the probability mixing and inverse CDF techniques.</li></ul></li>
 *    <li><b>Power Distribution</b>
 *     <ul>
 *      <li>\code 
 *          <Parameter name="example a" type="Power 1 Distribution" value="{2,0,1}"/>
 *          <Parameter name="example b" type="Power 1 Distribution" avlue="{0,1}"/>
 *          <Parameter name="example c" type="Power 2 Distribution" value="{3,1,2}"/>
 *          <Parameter name="example d" type="Power 2 Distribution" value="{1,2}"/>
 *          <Parameter name="example e" type="Power 10 Distribution" value="{1.0,1.5,5.5}"/>
 *          <Parameter name="example f" type="Power 10 Distribution" value="{1.5,5.5}"/>
 *          \endcode</li>
 *      <li>Models the power function \f$a x^N\f$ for \f$x \in [b,c]\f$, where
 *          \f$N\f$ is the desired power.</li>
 *       <li>The type attribute specifies the power \f$N\f$.</li>
 *       <li>The value attribute specifies the constant multiplier \f$a\f$
 *           (optional), the minimum \f$x\f$ value \f$b\f$ and the 
 *           maximum \f$x\f$ value \f$c\f$ respectively. The limits must be 
 *           strictly positive.</li>
 *       <li>The default value of \f$c\f$ is 1.0.
 *       <li>For sampling distributions, the constant multiplier \f$c\f$ will
 *           be replaced by a normalization constant.</li></ul></li>
 *     <li><b>Tabular Distribution</b>
 *      <ul>
 *       <li>\code
 *           <Parameter name="example a" type="Tabular LinLin Distribution" value="{{-1.0, -0.5, 0.0, 0.5, 1.0},{0.0, 1.0, 2.0, 3.0, 4.0 }}"/>
 *           <Parameter name="example b" type="Tabular LinLog Distribution" value="{{1e-3, 3l, 10.0},{-1.0, 3i, 1.0}}"/>
 *            <Parameter name="example c" type="Tabular LogLin Distribution" value="{{-1.0, 3i, 1.0},{1e-3, 3l, 10.0}}"/>
 *            <Parameter name="example d" type="Tabular LogLog Distribution" value="{{1e-3, 3l, 10.0},{1.0, 3l, 1e4}"/>
 *             \endcode</li>
 *        <li>The type attribute specifies the type of interpolation to use
 *            with the table.</li>
 *        <li>The value attribute specifies the \f$n\f$ independent values and 
 *            the \f$n\f$ dependent values.</li>
 *    <li>\ref interval_operators "Interval operators" can be used when 
 *        specifying this distribution.</li></ul></li>
 *      <li><b>Uniform Distribution</b>
 *       <ul>
 *        <li>\code
 *            <Parameter name="example a" type="Uniform Distribution" value="{-1,1,2}"/>
 *            <Parameter name="example b" type="Uniform Distribution" value="{-1,1}"/>
 *            \endcode</li>
 *        <li>Models the constant function \f$c\f$ for \f$x \in [a,b]\f$.</li>
 *        <li>The value attribute specifies the minimum \f$x\f$ value
 *            \f$a\f$, the maximum \f$x\f$ value \f$b\f$ and the
 *            constant \f$c\f$ (optional) respectively.</li>
 *        <li>The default value of \f$c\f$ is 1.0.</li>
 *        <li>For sampling distributions, the constant multiplier \f$c\f$ will
 *            be replaced by a normalization constant.</li></ul></li>   
 *  </ul>
 *
 * One more special operator that can be used with all one-dimensional 
 * distributions is the "pi" operator. Any "pi" value that appears will 
 * be replaced by the value of pi. It is also valid to multiply and divide
 * this pi operator (e.g. 2*pi, 2pi, 3*pi/4, 2pi / 5, etc.). 
 *
 * \section interval_operators Interval Operators
 * To avoid having to write out long sequences of values, two interval
 * operators have been defined: the linear interval operator (i) and the 
 * logarithmic interval operator (l). These operators are identical to the
 * "i" operator and "ilog" operators in MCNP.
 *
 * \section spatial_distributions Spatial Distributions
 * Before discussing the remaining XML files, a special parameter must be
 * discussed: the spatial distribution. Spatial distributions can be used to
 * represent a sampling distribution or a weighting function, much like the
 * \ref one_d_distributions "one-dimensional distributions". Each spatial 
 * distribution and a corresponding example parameter list will be shown below.
 * <ul>
 *  <li><b>Point Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution">
 *             <Parameter name="Position" type="Array(double)" value="{0.0,0.0,-501}"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Only one parameter element is required for this distribution: the
 *           "Position".
 *       <li>This distribution is for convenience since the Cartesian
 *           distribution can also be used to model a point.</li>
 *      </ul></li>
 *   
 *  <li><b>Cartesian Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution">
 *             <Parameter name="X Distribution" type="Uniform Distribution" value="{-10,-10,-10}"/>
 *             <Parameter name="Y Distribution" type="Uniform Distribution" value="{-10,-10,-10}"/>
 *             <Parameter name="Z Distribution" type="Uniform Distribution" value="{-10,-10,-10}"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Three parameters are required for this distribution: the "X 
 *           Distribution", the "Y Distribution" and the "Z Distribution".</li>
 *       <li>The type attribute for each parameter must be a 
 *           \ref one_d_distributions "one-d distribution".</li> 
 *       <li>The example distribution could be used to sample uniformly from a 
 *           cuboid volume.</li>
 *      </ul></li>
 *      
 *  <li><b>Cylindrical Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution">
 *             <Parameter name="R Distribution" type="Power 1 Distribution" value="{1.0, 0.0, 1.0}"/>
 *             <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0,2pi,1}"/>
 *             <Parameter name="Axis Distribution" type="Uniform Distribution" value="{-10,10,1}"/>
 *             <Parameter name="Center X Position" type="double" value="0.0"/>
 *             <Parameter name="Center Y Position" type="double" value="0.0"/>
 *             <Parameter name="Center Z Position" type="double" value="0.0"/>
 *             <Parameter name="Axis" type="string" value="Z"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Seven parameters are required for this distribution: the "R
 *           Distribution", the "Theta Distribution", the "Axis Distribution",
 *           the "Center X Position", the "Center Y Position", the
 *           "Center Z Position" and the "Axis".</li>
 *       <li>The "Axis Distribution" specifies the distribution along the
 *           axis of the cylinder, the orientation of which can be specified
 *           using the "Axis" parameter.</li>
 *       <li>The type attribute for each of the distribution parameters must be
 *           a \ref one_d_distributions "one-d distribution".</li>
 *       <li>There are three valid values for the "Axis" parameter: "X", "Y"
 *           and "Z".
 *       <li>The example distribution could be used to sample uniformly from a
 *           right circular cylindrical volume.</li>
 *      </ul></li>
 *
 *  <li><b>Spherical Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution"
 *             <Parameter name="R Distribution" type="Power 2 Distribution" value="{2.0, 0.0, 1.0}"/>
 *             <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0,2pi,1}"/>
 *             <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1,1,1.0}"/>
 *             <Parameter name="Center X Position" type="double" value="0.0"/>
 *             <Parameter name="Center Y Position" type="double" value="0.0"/>
 *             <Parameter name="Center Z Position" type="double" value="0.0"/>
 *             <Parameter name="Axis" type="string" value="Z"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Seven parameters are required for this distribution: the "R
 *           Distribution", the "Theta distribution", the "Mu Distribution",
 *           the "Center X Position", the "Center Y Position", the "Center Z
 *           Position" and the "Axis".</li>
 *       <li>The "Theta Distribution" specifies the distribution of the
 *           azimuthal angle while the "Mu Distribution" specifies the
 *           distribution of the polar angle cosine.</li>
 *       <li>The "Axis" parameter is used to specify the axis from which the
 *           the polar angle cosine is measured. The three valid values are
 *           "X", "Y" and "Z".
 *       <li>The type attribute for each of the distribution parameters must be
 *           a \ref one_d_distributions "one-d distribution".</li>
 *       <li>The example distribution could be used to sample uniformly from
 *           a spherical volume.</li>
 *      </ul></li>
 *
 * </ul>
 *
 * \section directional_distributions Directional Distributions
 * The final special parameter that must be discussed is the directional
 * distribution. Directional distributions can be used to represent a
 * sampling distribution or a weighting function, much like the 
 * \ref one_d_distributions "one-dimensional distributions" and the 
 * \ref spatial_distributions "spatial distributions". Each directional 
 * distribution and a corresponding example parameter list will be shown below.
 * <ul>
 *  <li><b>Mono-directional Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Directional Distribution">
 *             <Parameter name="Direction" type="Array(double)" value="{1.0,1.0,1.0}"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Only one parameter element is required for this distribution: the
 *           "Direction".</li>
 *       <li>The direction specified does not need to be normalized. It will
 *           be normalized upon being read in.</li>
 *       <li>This distribution is for convenience since the spherical 
 *           distribution can also be used to model a mono-directional
 *           distribution.</li>
 *      </ul></li>
 * 
 *  <li><b>Spherical Distribution</b>
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Directional Distribution">
 *             <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1.0,1.0,2}"/>
 *             <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0,2pi,1}"/>
 *             <Parameter name="Axis" type="string" value="Z"/>
 *           </ParameterList>
 *           \endcode</li>
 *       <li>Only one parameter element is required for this distribution: the
 *           "Mu Distribution".</li>
 *       <li>The "Mu Distribution" parameter specifies the distribution of the 
 *           polar angle cosine.</li>
 *       <li>If the optional "Axis" parameter is specified, the polar angle
 *           cosine will be measured with respect to the specified axis. The
 *           three valid axis values are "X", "Y" and "Z" (default).</li>
 *       <li>The "Theta Distribution" parameter specifies the distribution of
 *           the azimuthal angle. If it is not specified, the azimuthal angle
 *           will be sampled uniformly.</li>
 *       <li>The type attribute for the two distribution parameters must be
 *           a \ref one_d_distributions "one-d distribution".</li>
 *      </ul></li>
 *
 * \section response_function_construction Response Function Construction
 * Two types of response functions are currently supported: the energy
 * response function and the phase space response function. Both of these
 * will be discussed before discussing the construction of the response 
 * function XML file.
 *
 * \subsection energy_response_function The Energy Response Function
 * The energy response function is a user defined function with a dependence
 * on the particles energy only. Two parameter elements must appear in every
 * energy response function. These required parameters will be described below.
 * <ol>
 *  <li>The first parameter element is the response function id. Every
 *      response function needs to have a unique id, which can be used by the
 *      estimators. 
 *      <ul>
 *       <li>\code
 *           <Parameter name="Id" type="unsigned int" value="1"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The second parameter element is the energy distribution, which can be 
 *      any of the \ref one_d_distributions "one-dimensional distributions". 
 *      <ul>
 *       <li>\code
 *           <Parameter name="Energy Distribution" type="Histogram Distribution" value="{{1e-3,2l,1.0,8i,10.0,20.0},{0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.35,0.3,0.25,0.2,0.15,0.1}}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 * \subsection phase_space_response_function The Phase Space Response Function
 * The phase space response function is a generalized version of the 
 * energy response function that is dependent on the entire phase space. Five
 * parameter elements must appear in every phase space response function. These
 * required parameters will be described below.
 * <ol>
 *  <li>The first parameter element is the response function id, which can be
 *      used by the estimators.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Id" type="unsigned int" value="1"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The second element is the spatial distribution which is itself a 
 *      parameter list. Please refer to the
 *      \ref spatial_distributions "spatial distributions" section for
 *      information regarding the construction of spatial distributions.
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution">
 *             <Parameter name="X Distribution" type="Uniform Distribution" value="{-10,10,1.0}"/>
 *             <Parameter name="Y Distribution" type="Uniform Distribution" value="{-10,10,1.0}"/>
 *             <Parameter name="Z Distribution" type="Uniform Distribution" value="{-10,10,1.0}"/>
 *           </ParameterList>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The third element is the directional distribution which is also a 
 *      parameter list. Please refer to the
 *      \ref directional_distributions "directional distributions" section for
 *      information regarding the construction of directional distributions.
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Directional Distribution">
 *             <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1.0,1.0,1.0}"/>
 *             <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0,2pi,1}"/>
 *           </ParameterList>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The fourth parameter element is the energy distribution, which can be 
 *      any of the \ref one_d_distributions "one-dimensional distributions". 
 *      <ul>
 *       <li>\code
 *           <Parameter name="Energy Distribution" type="Histogram Distribution" value="{{1e-3,2l,1.0,8i,10.0,20.0},{0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.35,0.3,0.25,0.2,0.15,0.1}}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The fifth element is the time distribution, which can also be any
 *      of the \ref one_d_distributions "one-dimensional distributions".
 *      <ul>
 *       <li>\code
 *           <Parameter name="Time Distribution" type="Uniform Distribution" value="{0.0,1e10,1.0}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 * \subsection example_resp_func_xml_file Example Response Function XML File
 * An example response function xml file is given below.
 * \code
 * <ParameterList name="Response Functions">
 *   
 *   <ParameterList name="Energy Response">
 *     <Parameter name="Id" type="unsigned int" value="0"/> 
 *     <Parameter name="Energy Distribution" type="Histogram Distribution" value="{{1e-3,1e-2,1e-1,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,20.0},{0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.35,0.3,0.25,0.2,0.15,0.1}}"/>
 *   </ParameterList>
 *
 *   <ParameterList name="Phase Space Response: Cartesian">
 *     <Parameter name="Id" type="unsigned int" value="1"/>
 *     <ParameterList name="Spatial Distribution">
 *       <Parameter name="X Distribution" type="Uniform Distribution" value="{-1e50,1e50,1.0}"/>
 *       <Parameter name="Y Distribution" type="Uniform Distribution" value="{-1e50,1e50,1.0}"/>
 *       <Parameter name="Z Distribution" type="Uniform Distribution" value="{-1e50,1e50,1.0}"/>
 *     </ParameterList>
 *     <ParameterList name="Directional Distribution">
 *       <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1.0,1.0,1.0}"/> 
 *       <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0.0, 6.283185307179586, 1.0}"/>
 *     </ParameterList>
 *     <Parameter name="Energy Distribution" type="Histogram Distribution" value="{{1e-3,1e-2,1e-1,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,20.0},{0.1,0.15,0.2,0.25,0.3,0.35,0.4,0.35,0.3,0.25,0.2,0.15,0.1}}"/>
 *     <Parameter name="Time Distribution" type="Uniform Distribution" value="{0.0,1e50,1.0}"/>
 *   </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * \section estimator_construction Estimator Construction
 * There are currently six types of estimators that can be created: the
 * surface current estimator, the surface flux estimator, the cell track-length
 * flux estimator, the cell collision flux estimator, the cell pulse height 
 * estimator and the tet mesh track-length flux estimator. Each estimator 
 * requires several parameters. There are also several optional parameters.
 *
 * \subsection required_estimator_parameters Required Estimator Parameters
 * <ol>
 *  <li>The first parameter element that every estimator needs is the id 
 *      parameter. Every estimator must have a unique id. If DAGMC is being 
 *      used, the estimator id can be specified in CUBIT. To further modify 
 *      the estimator defined in CUBIT, the same id must be specified in the 
 *      id parameter.
 *   <ul>
 *    <li>\code
 *        <Parameter name="Id" type="unsigned int" value="1"/>
 *        \endcode</li>
 *   </ul></li>
 *
 *  <li>The second parameter element is the type parameter. The following type
 *      parameter value attributes are valid: Surface Current, Surface Flux, 
 *      Cell Track-Length Flux, Cell Collision Flux, Cell Pulse Height and
 *      Tet Mesh Track-Length Flux.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Type" type="string" value="Surface Current"/>
 *           <Parameter name="Type" type="string" value="Surface Flux"/>
 *           <Parameter name="Type" type="string" value="Cell Track-Length Flux"/>
 *           <Parameter name="Type" type="string" value="Cell Collision Flux"/>
 *           <Parameter name="Type" type="string" value="Cell Pulse Height"/>
 *           <Parameter name="Type" type="string" value="Tet Mesh Track-Length Flux"/>
 *           \endcode</li>
 *      </ul>
 *      If DAGMC is being used, the estimator type can also be specified in 
 *      CUBIT (except for the tet mesh estimator). The default type keywords 
 *      are the following:
 *      <ul>
 *       <li>surface.current (Surface Current),</li>
 *       <li>surface.flux (Surface Flux),</li>
 *       <li>cell.tl.flux (Cell Track-Length Flux),</li>
 *       <li>cell.c.flux (Cell Collision Flux),</li>
 *       <li>cell.pulse.height (Cell Pulse Height).</li>
 *      </ul>
 *      However, these keywords can be substituted with any alternative of your
 *      choosing (these alternatives must be specified in the 
 *      \ref geometry_xml_file "geometry xml file").</li>
 *  <li>The third parameter element is the particle type parameter. This 
 *      parameter specifies which particles can contribute to the estimator. 
 *      Currently, the only valid particle types are: Neutron, Photon
 *      and Electron.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Particle Type" type="string" value="Neutron"/>
 *           <Parameter name="Particle Type" type="string" value="Photon"/>
 *           <Parameter name="Particle Type" type="string" value="Electron"/>
 *           \endcode</li>
 *      </ul>
 *      If DAGMC is being used, the particle type can also be specified in 
 *      CUBIT using a corresponding shorthand:
 *      <ul>
 *       <li>n (Neutron)</li>
 *       <li>p (Photon)</li>
 *       <li>e (electron)</li>
 *      </ul></li>
 *
 *  <li><b>Tet Mesh Track-Length Flux Estimator:</b> The fourth parameter
 *         element is the mesh file name parameter. The tet mesh must be
 *         preconstructed and stored in an h5m or vtk file. This parameter
 *         specifies the desired mesh file.
 *         <ul>
 *          <li>\code
 *              <Parameter name="Mesh File Name" type="string" value="mesh_name.vtk"/>
 *              <Parameter name="Mesh File Name" type="string" value="mesh_name.h5m"/>
 *              \endcode</li>
 *         </ul>
 *
 *      <b>Non Mesh Estimators:</b>The fourth parameter element is the 
 *         surfaces or cells parameter. This parameter specifies which surfaces
 *         (for surface estimators) or cells (for cell estimators) the 
 *         estimator will watch. Every estimator must have at least one cell or
 *         surface to watch. If DAGMC is being used, the cells or surfaces 
 *         associated with an estimator can be specified in CUBIT. Any other
 *         cells or surfaces specified in this parameter element will be added
 *         to the list specified in CUBIT (technically the union will be 
 *         taken).
 *         <ul>
 *          <li>\code
 *              <Parameter name="Surfaces" type="Array" value="{1,2,3}"/>
 *              <Parameter name="Cells" type="Array" value="{4,5}"/>
 *              \endcode</li>
 *         </ul></li>
 *  <li><b>Tet Mesh Track-Length Flux Estimator:</b> The fifth parameter
 *        element is the output mesh file name. The output file type can 
 *        be specified using the suffix ".vtk" for VTK files or ".h5m" for
 *        H5M files.
 *        <ul>
 *         <li>\code
 *             <Parameter name="Output Mesh File Name" type="string" value="output_mesh_name.vtk"/>
 *             <Parameter name="Output Mesh File Name" type="string" value="output_mesh_name.h5m"/>
 *             \endcode</li>
 *        </ul></li>
 * </ol>
 *
 * \subsection optional_estimator_parameters Optional Estimator Parameters
 * <ol> 
 *  <li>The first optional parameter element is the response function 
 *      parameter. This parameter specifies the response functions (ids) that 
 *      should be used with the estimator.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Response Functions" type="Array" value="{0,1}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The second optional parameter element is the multiplier parameter. This
 *      parameter specifies the multiplier (or scaling factor) that should be
 *      applied to the multiplier. This will typically be used to scale the
 *      estimator to a specific source strength.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Multiplier" type="double" value="1.0"/>
 *           \endcode</li>
 *      </ul></li>
 *  
 *  <li>The third optional argument is the energy multiplication parameter.
 *      This parameter is used to indicate that estimator results should be
 *      multiplied by the particle energy.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Energy Multiplication" type="bool" value="true"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The final optional parameter element is the bins parameter list. The 
 *      bins parameter list will contain the phase space binning desired for 
 *      the estimator. The phase space bins that can currently be specified are
 *      the following:
 *      <ul>
 *       <li>Energy Bins</li>
 *       <li>Time Bins</li>
 *       <li>Cosine Bins</li>
 *       <li>Collision Number Bins</li>
 *       <li>Generation Number Bins</li>
 *      </ul>
 *      The order that the different phase space bins are specified in is 
 *      important. The first bins specified will run the fastest (they will be
 *      added to all of the later bins specified). \ref interval_operators 
 *      "Interval operators" can be used when specifying estimator bins.
 *      <ul>
 *       <li>\code
 *        <ParameterList name="Bins">
 *         <Parameter name="Energy Bins" type="Array" value="{1e-3,2l,1.0}"/>
 *         <Parameter name="Time Bins" type="Array" value="{0.0, 2i, 10.0}"/>
 *         <Parameter name="Cosine Bins" type="Array" value="{-1.0, 3i, 1.0}"/>
 *         <Parameter name="Collision Number Bins" type="Array" value="{0 1 2 3 10}"/>
 *         <Parameter name="Generation Number Bins" type="Array" value="{0 1 2 10}"/>
 *        </ParameterList>
 *        \endcode</li>
 *      </ul></li>
 * </ol>
 *
 * Note that if only basic estimators are required and DAGMC is being used
 * all of the estimators can be defined in CUBIT. This will leave the 
 * estimators xml file empty.
 *
 * \subsection example_estimator_xml_file Example Estimator XML File
 * An example estimator xml file is given below.
 * \code
 * <ParameterList name="Estimators">
 *
 * <ParameterList name="Cell Track Length Flux Estimator">
 *   <Parameter name="Id" type="unsigned int" value="1"/>
 *   <Parameter name="Type" type="string" value="Cell Track-Length Flux"/>
 *   <Parameter name="Multiplier" type="double" value="2.0"/>
 *   <Parameter name="Response Functions" type="Array" value="{0}"/>
 *   <ParameterList name="Bins">
 *     <Parameter name="Energy Bins" type="Array" value="{1e-3,2l,1.0,8i,10.0,20.0}"/>
 *     <Parameter name="Time Bins" type="Array" value="{0.0, 1e-9, 1e-8, 1e-7, 1.0}"/>
 * </ParameterList>
 * 
 * <ParameterList name="Cell Collision Flux Estimator">
 *  <Parameter name="Id" type="unsigned int" value="2"/>
 *  <Parameter name="Type" type="string" value="Cell Collision Flux"/>
 *  <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  <Parameter name="Multiplier" type="double" value="1.0"/>
 *  <Parameter name="Response Functions" type="Array" value="{0,1}"/>
 *  <ParameterList name="Bins">
 *    <Parameter name="Energy Bins" type="Array" value="{1e-3,1e-2,1e-1,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,20.0}"/>
 *    <Parameter name="Collision Number Bins" type="Array" value="{0, 1, 2, 10}"/>
 *  </ParameterList>
 * </ParameterList>
 *
 * <ParameterList name="Pulse Height Estimator">
 *  <Parameter name="Id" type="unsigned int" value="3"/>
 *  <Parameter name="Type" type="string" value="Cell Pulse Height"/>
 *  <Parameter name="Particle Type" type="string" value="Photon"/>
 *  <Parameter name="Multiplier" type="double" value="1.0"/>
 *  <Parameter name="Cells" type="Array" value="{1,26}"/>
 *  <Parameter name="Energy Multiplication" type="bool" value="true"/>
 *  <ParameterList name="Bins">
 *    <Parameter name="Energy Bins" type="Array" value="{1e-3,2l,1.0,8i,10.0,20.0}"/>
 *  </ParameterList>
 * </ParameterList>

 * <ParameterList name="Surface Flux Estimator">
 *  <Parameter name="Id" type="unsigned int" value="4"/>
 *  <Parameter name="Type" type="string" value="Surface Flux"/>
 *  <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  <Parameter name="Multiplier" type="double" value="2.0"/>
 *  <Parameter name="Surfaces" type="Array" value="{7,16,25}"/>
 *  <ParameterList name="Bins">
 *    <Parameter name="Cosine Bins" type="Array" value="{-1.0, -0.5, 0.0, 0.5, 1.0}"/>
 *    <Parameter name="Energy Bins" type="Array" value="{1e-3,2l,1.0,8i,10.0,20.0}"/>
 *  </ParameterList>
 * </ParameterList>
  
 * <ParameterList name="Surface Current Estimator">
 *  <Parameter name="Id" type="unsigned int" value="5"/>
 *  <Parameter name="Type" type="string" value="surface.current"/>
 *  <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  <Parameter name="Multiplier" type="double" value="2.0"/>
 *  <Parameter name="Surfaces" type="Array" value="{7,16,25}"/>
 *  <ParameterList name="Bins">
 *    <Parameter name="Cosine Bins" type="Array" value="{-1.0, -0.5, 0.0, 0.5, 1.0}"/>
 *    <Parameter name="Collision Number Bins" type="Array" value="{0, 1, 2, 10}"/>
 *  </ParameterList>
 * </ParameterList>
 *
 * <ParameterList name="Tet Mesh Estimator">
 *  <Parameter name="Id" type="unsigned int" value="6"/>
 *  <Parameter name="Type" type="string" value="Tet Mesh Track-Length Flux"/>
 *  <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  <Parameter name="Multiplier" type="double" value="1.0"/>
 *  <Parameter name="Mesh File Name" type="string" value="my_mesh.vtk"/>
 *  <Parameter name="Output Mesh File Name" type="string" value="my_mesh_data.vtk"/>
 *  <ParameterList name="Bins">
 *   <Parameter name="Energy Bins" type="Array" value="{1e-3,2l,1.0,8i,10.0,20.0}"/>
 *  </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * \section ptrac_construction Particle Tracker Construction
 * The particle tracker is an event tracker, similar to any of the estimators
 * discussed elsewhere in this manual. However, the particle tracker acts as a
 * global observer, keeping track of a specified number of particle histories
 * and each particle's state variables throughout its lifetime. 
 *
 * \subsection ptrac_data Particle Tracker Data
 * The particle tracker keeps track of particle states throughout their lifetimes.
 * For a given number of histories, all source particles in that history number
 * range, as well as all progeny (i.e. particles whose generation can be 
 * traced back to the source particle) will be tracked. For each particle, at 
 * every collision and particle destruction the following pieces of data are
 * tracked:
 *
 * <ul> 
 *  <li> X Position </li>
 *  <li> Y Position </li>
 *  <li> Z Position </li>
 *  <li> X Direction </li>
 *  <li> Y Direction </li>
 *  <li> Z Direction </li>
 *  <li> Collision Number </li>
 *  <li> Energy </li>
 *  <li> Weight </li>
 * </ul>
 *
 * This data is then organized into maps with the following heirarchy:
 * [History Number]->[Particle Type]->[Generation Number]->[Individual Particle Number]->[Lifetime Data]
 *
 * The data will be output to an HDF5 file (the same as any estimators) in a 
 * separate directory.
 *
 * \subsection required_ptrac_parameters Particle Tracker Parameters
 * <ol> 
 *  <li>The first required parameter element is the id. Note that the id for 
 *      the particle tracker must be unique with respect to all other estimators.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Id" type="int" value="1"/>
 *           \endcode</li>
 *      </ul></li>
 * <li>The second required parameter is the type name. In this case the required
 *     type name is "Particle Tracker"
 *      <ul>
 *       <li>\code
 *           <Parameter name="Type" type="string" value="Particle Tracker"/>
 *           \endcode</li>
 *      </ul></li>
 *  <li>The final parameter is optional and is the number of histories that will be 
 *       tracked. Note that the default assignment for this parameter is 100.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Histories" type="unsigned int" value="100"/>
 *           \endcode</li>
 *      </ul></li>
 * </ol>
 *
 * \subsection ptrac_example Particle Tracker Example
 *
 * \code
 * <ParameterList name="Observers">

 * <ParameterList name="Particle Tracker 1">
 *   <Parameter name="Id" type="unsigned int" value="1"/>
 *   <Parameter name="Type" type="string" value="Particle Tracker"/>
 *   <Parameter name="Histories" type="unsigned int" value="500" />
 * </ParameterList>
 * 
 * </ParameterList>
 * \endcode
 *
 * \section source_construction Source Construction
 * There are currently two types of sources that can be created: the 
 * distributed source and the compound source. 
 *  The compound source is a series of distributed sources that have 
 * been combined to define a more complicated source. 
 *
 * \subsection distributed_source Distributed Source Construction
 * The distributed source is simply a phase space distribution that can be 
 * sampled from to get particle starting states. Every distributed source 
 * requires four parameter elements. There are also two optional parameter
 * elements. These parameter elements will be described below.
 *
 * <b>Required Parameters:</b>
 * <ol> 
 *  <li>The first required parameter element is the id. This parameter becomes
 *      more important when defining compound sources.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Id" type="int" value="1"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The second required parameter element is the particle type. This 
 *      parameter specifies the particle type that will be generated by the 
 *      source. Currently, the only valid particle types are "Neutron," 
 *      "Photon" and "Electron".
 *      <ul>
 *       <li>\code
 *           <Parameter name="Particle Type" type="string" value="Neutron"/>
 *           <Parameter name="Particle Type" type="string" value="Photon"/>
 *           <Parameter name="Particle Type" type="string" value="Electron"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The third required element is the spatial distribution, which is itself
 *      a parameter list. Please refer to the
 *      \ref spatial_distributions "spatial distributions" section for 
 *      information regarding the construction of spatial distributions.
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Distribution">
 *             <Parameter name="X Distribution" type="Uniform Distribution" value="{-10,10}"/>
 *             <Parameter name="Y Distribution" type="Uniform Distribution" value="{-10,10}"/>
 *             <Parameter name="Z Distribution" type="Uniform Distribution" value="{-10,10}"/>
 *           </ParameterList>
 *           \endcode</li>
 *      </ul></li>
 *  
 *  <li>The last required element is the energy distribution, which can be any
 *      of the \ref one_d_distributions "one-dimensional distributions".
 *      <ul>
 *       <li>\code
 *           <Parameter name="Energy Distribution" type="Exponential Distribution" value="{1.0,0.5}"/>
 *           \endcode</li>
 *      </ul></li>
 * </ol>
 * 
 * <b>Optional Parameters:</b>
 * <ol>
 *  <li>The first optional element is the directional distribution, which is 
 *      also a parameter list. Please refer to the 
 *      \ref directional_distributions "directional distributions" section for
 *      information regarding the construction of directional distributions.
 *      The default directional distribution is isotropic.
 *       <ul>
 *        <li>\code
 *            <ParameterList name="Directional Distribution">
 *              <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1.0,1.0}"/>
 *            </ParameterList>
 *            \endcode</li>
 *       </ul></li>
 *
 *  <li>The second optional element is the time distribution, which can be any
 *      of the \ref one_d_distributions "one-dimensional distributions".
 *      <ul>
 *       <li>\code
 *           <Parameter name="Time Distribution" type="Delta Distribution" value="{0}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The third optional element is the rejection cell. When a source's
 *      spatial distribution is too complicated to be modeled with one of
 *      the available spatial distribution types, one can specify a rejection
 *      cell (or cells) that will be used in conjunction with the defined 
 *      spatial distribution. After a point is sampled from the spatial 
 *      distribution, the point is only used if it falls within one of the
 *      rejection cells. 
 *      <ul>
 *       <li>\code
 *           <Parameter name="Rejection Cells" type="Array" value="{1,2}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The fourth optional element is the spatial importance function. When
 *      the spatial importance function is specified, it is treated as the
 *      true distribution of particle positions. The particle position is
 *      first sampled from the spatial distribution and then the particle
 *      weight at that point is determined from the spatial importance
 *      function. Please refer to the
 *      \ref spatial_distributions "spatial distributions" section for 
 *      information regarding the construction of spatial importance functions.
 *      It is important that the spatial distribution type and the
 *      spatial importance function type are the same.
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Spatial Importance Function">
 *             <Parameter name="X Distribution" type="Histogram Distribution" value="{{-10,0,10},{2,1}}"/>
 *             <Parameter name="Y Distribution" type="Histogram Distribution" value="{{-10,0,10},{2,1}}"/>
 *             <Parameter name="Z Distribution" type="Histogram Distribution" value="{{-10,0,10},{2,1}}"/>
 *           </ParameterList>
 *           \endcode</li>
 *      </ul></li>
 *   
 *  <li>The fifth optional element is the directional importance function. When
 *      the directional importance function is specified, it is treated as the
 *      true distribution of particle directions. The particle direction is
 *      first sampled from the directional distribution and then the particle
 *      weight at that direction is determined from the directional importance
 *      function. Please refer to the
 *      \ref directional_distributions "directional distributions" section for
 *      information regarding the construction of directional importance 
 *      functions. It is important that the directional distribution type and
 *      the directional importance function type are the same.
 *      <ul>
 *       <li>\code
 *           <ParameterList name="Directional Importance Function"/>
 *             <Parameter name="Mu Distribution" type="Histogram Distribution" value="{{-1,0,1},{1,2}}"/>
 *             <Parameter name="Theta Distribution" type="Histogram Distribution" value="{{0,pi,2pi},{1,2}}"/>
 *           </ParameterList>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The sixth optional parameter element is the energy importance 
 *      function. When the energy importance function is specified, it is
 *      treated as the true distribution of particle energies. The particle
 *      energy is first sampled from the energy distribution and then the
 *      particle weight at that energy is determined from the energy 
 *      importance function. The energy importance function can be any of the
 *      \ref one_d_distributions "one-dimensional distributions". It is
 *      important that the energy importance function and the energy 
 *      distribution share the same energy bounds.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Energy Importance Function" type="Normal Distribution" value="{1,1,0,inf}"/>
 *           \endcode</li>
 *      </ul></li>
 *   
 *  <li>The seventh optional parameter element is the time importance
 *      function. When the time importance function is specified, it is
 *      treated as the true distribution of particle times. The particle
 *      time is first sampled from the time distribution and then the
 *      particle weight at that time is determined from the time importance
 *      function. The time importance function can be any of the \ref
 *      one_d_distributions "one-dimensional distributions". It is important
 *      that the time importance function and the time distribution share
 *      the same time bounds.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Time Importance Function" type="Uniform Distribution" value="{0,1e10,1}"/>
 *           \endcode</li>
 *      </ul></li>
 *
 *  <li>The final optional parameter element is the source weight. This
 *      parameter is only used when there are multiple sources defined (see
 *      the next subsection on 
 *      \ref compound_source "compound source construction". The compound
 *      source uses this parameter to determine which distributed source
 *      to sample from.
 *      <ul>
 *       <li>\code
 *           <Parameter name="Weight" type="double" value="1.0"/>
 *           \endcode</li>
 *      </ul></li>
 * </ol>
 *
 * <b>Example Source XML Files:</b>
 * <ul>
 *  <li>\code
 * <ParameterList name="Source">
 * 
 * <ParameterList name="Basic Distributed Source">
 *   <Parameter name="Id" type="int" value="1"/>
 *
 *  <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  
 *  <ParameterList name="Spatial Distribution">
 *    <Parameter name="X Distribution" type="Delta Distribution" value="{1}"/>
 *    <Parameter name="Y Distribution" type="Delta Distribution" value="{1}"/>
 *    <Parameter name="Z Distribution" type="Delta Distribution" value="{1}"/>
 *  </ParameterList>
 *  
 *  <Parameter name="Energy Distribution" type="Exponential Distribution" value="{2,0.5}"/>
 *
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode</li>
 *
 * <li>\code
 * <ParameterList name="Source">
 *  
 * <ParameterList name="Complex Distributed Source">
 *   <Parameter name="Id" type="int" value="1"/>
 *
 *   <ParameterList name="Spatial Distribution">
 *     <Parameter name="X Distribution" type="Uniform Distribution" value="{0,1,1}"/>
 *     <Parameter name="Y Distribution" type="Uniform Distribution" value="{0,1,1}"/>
 *     <Parameter name="Z Distribution" type="Uniform Distribution" value="{0,1,1}"/>
 *   </ParameterList>
 *
 *   <ParameterList name="Spatial Importance Function">
 *     <Parameter name="X Distribution" type="Histogram Distribution" value="{{0,0.5,1},{2,1}}"/>
 *     <Parameter name="Y Distribution" type="Histogram Distribution" value="{{0,0.5,1},{2,1}}"/>
 *     <Parameter name="Z Distribution" type="Histogram Distribution" value="{{0,0.5,1},{2,1}}"/>
 *   </ParameterList>
 *  
 *   <ParameterList name="Directional Distribution">
 *     <Parameter name="Mu Distribution" type="Uniform Distribution" value="{-1,1,2}"/>
 *     <Parameter name="Theta Distribution" type="Uniform Distribution" value="{0,2pi,1}"/>
 *   </ParameterList>
 *  
 *   <Parameter name="Energy Distribution" type="Uniform Distribution" value="{1e-5,1,1}"/>
 *    
 *   <Parameter name="Energy Importance Function" type="Normal Distribution" value="{1,1,1e-5,1}"/>
 *
 *   <Parameter name="Time Distribution" type="Delta Distribution" value="{0}"/>
 *
 *   <Parameter name="Rejection Cell" type="int" value="2"/>
 *
 *   <Parameter name="Particle Type" type="string" value="Neutron"/>
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode</li>
 * </ul>
 *
 * \subsection compound_source Compound Source Construction
 * To construct a compound source, one simply needs to define several sources,
 * each with a unique id, and assign a weight to each. The weight parameter 
 * element must be specified for each source. If the weight parameter is
 * not specified for a source, a default value of 1.0 will be used. These 
 * weights will be used to sample a source to use for sampling a particle 
 * state. Typically, the weight will be set to the spatial volume occupied by 
 * each distributed source. The weights do not need to be normalized - they
 * will be normalized once they have been read in.
 *
 * <b>Example Source XML File:</b>
 *
 * \code
 * <ParameterList name="Source">
 *
 *   <ParameterList name="Neutron Source">
 *     <Parameter name="Id" type="int" value="1"/>
 *
 *     <Parameter name="Particle Type" type="string" value="Neutron"/>
 *  
 *     <ParameterList name="Spatial Distribution">
 *       <Parameter name="X Distribution" type="Delta Distribution" value="{0}"/>
 *       <Parameter name="Y Distribution" type="Delta Distribution" value="{0}"/>
 *       <Parameter name="Z Distribution" type="Delta Distribution" value="{0}"/>
 *     </ParameterList>
 *  
 *     <Parameter name="Energy Distribution" type="Delta Distribution" value="{1}"/>
 *
 *     <Parameter name="Weight" type="double" value="1.0"/>
 *   </ParameterList>
 *
 *   <ParameterList name="Photon Source">
 *     <Parameter name="Id" type="int" value="2"/>
 *
 *     <Parameter name="Particle Type" type="string" value="Photon"/>
 * 
 *     <ParameterList name="Spatial Distribution">
 *       <Parameter name="X Distribution" type="Delta Distribution" value="{0}"/>
 *       <Parameter name="Y Distribution" type="Delta Distribution" value="{0}"/>
 *       <Parameter name="Z Distribution" type="Delta Distribution" value="{0}"/>
 *     </ParameterList>
 * 
 *     <Parameter name="Energy Distribution" type="Delta Distribution" value="{1}"/>
 *    
 *     <Parameter name="Weight" type="double" value="4.0"/>
 *   </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * \section runtime_configuration Runtime Configuration Settings
 * There are many runtime configuration settings. Only two of these
 * settings require specification. Both the required and optional settings
 * will be discussed in the following subsections.
 *
 * \subsection required_runtime_options Required Runtime Configuration Settings
 * The two settings that must be specified are the particle mode and the number
 * of histories to simulate.
 *
 * <ol>
 *  <li>The particle mode is used by facemc to determine which particles will 
 *      be simulated and which cross section info needs to be loaded. The 
 *      acceptable modes are "Electron", "Photon", "Neutron" and 
 *      "Neutron-Photon". More coupled physics modes will be available in the 
 *      future (e.g. "Photon-Electron"). An example mode specification is shown
 *      below:
 *      \code
 *      <Parameter name="Mode" type="string" value="Neutron"/>
 *      \endcode</li>
 *
 *  <li>The number of histories to simulate must also be specified. The 
 *      following parameter line is an example of this specification. 
 *      \code
 *      <Parameter name="Histories" type="unsigned int" value="1000000"/>
 *      \endcode
 *      Please note that scientific notation is not allowed when specifying the
 *      number of histories (yet).</li>
 * </ol>
 * 
 * An example of a basic runtime configuration xml file is shown below:
 *
 * \code
 * <ParameterList name="Properties">
 *
 * <ParameterList name="General Properties">
 * 
 *   <Parameter name="Mode" type="string" value="Neutron-Photon"/>
 *   <Parameter name="Histories" type="unsigned int" value="10"/>
 *
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * \subsection optional_general_runtime_settings Optional General Runtime Configuration Settings
 * There are three optional general runtime configuration settings:
 * The surface flux angle cosine cutoff, implicit capture mode, and the
 * ideal batches per processor.
 *
 * The surface flux angle cosine cutoff is used by surface flux estimators to 
 * avoid a divide-by-zero that is possible in the calculation of surface flux 
 * contributions. When the angle cosine is below the angle cosine cutoff, an 
 * approximation for the surface flux contribution is used. The value must be 
 * between 0 and 1. The default value is 0.001 (MCNP uses a default value of 
 * 0.1). An example specification of this setting is shown below:
 * \code
 * <Parameter name="Surface Flux Angle Cosine Cutoff" type="double" value="0.1"/>
 * \endcode
 *
 * If you want the simulation to treat capture implicitly (by modifying the 
 * particle weight) implicit capture should be turned on (it is turned off
 * by default). The parameter line shown below should be used to turn on
 * implicit capture mode.
 * \code
 * <Parameter name="Implicit Capture" type="bool" value="true"/>
 * \endcode
 *
 * The ideal batches per processor setting is only used when FACEMC has
 * been built with MPI and is being run with "mpiexec" with more than one
 * processor. The value given determines the size of batches that will be 
 * created and assigned to worker nodes. The default value is one, which means 
 * that each worker node will get one batch of particle histories to simulate 
 * (the sum of the worker batch sizes is the total number of histories). On 
 * distributed systems with heterogeneous nodes (i.e. nodes with different 
 * CPUs, RAM size/speed, etc.) increasing the number of batches per processor 
 * can improve load balancing. Determining the optimal value for a system will 
 * require trial and error. On distributed systems with homogeneous nodes, the 
 * default value of one should be used. An example specification of this 
 * setting is shown below:
 * \code
 * <Parameter name="Ideal Batches Per Processor" type="unsigned int" value="25"/>
 * \endcode
 *
 * Note that all of the required and optional general runtime configuration 
 * settings are placed within a parameter list with the name 
 * "General Properties".
 *
 * \subsection optional_neutron_runtime_settings Optional Neutron Runtime Configuration Settings
 * There are two optional neutron runtime configuration settings: the
 * free gas threshold and the minimum neutron energy.
 *
 * The free gas threshold is used by elastic neutron scattering to determine 
 * when the free gas thermal treatment should be used. The threshold is the 
 * number of times above the material temperature that the neutron energy can 
 * be before the free gas thermal treatment is no longer used. The default 
 * value is 400. An example specification of this setting is shown below:
 * \code
 * <Parameter name="Free Gas Threshold" type="double" value="600.0"/>
 * \endcode
 *
 * The minimum neutron energy is used by FACEMC to kill neutrons that fall
 * below that energy. The default value is 1e-11 MeV. An example specification
 * of this setting is shown below:
 * \code
 * <Parameter name="Min Neutron Energy" type="double" value="1e-10"/>
 * \endcode
 *
 * Note that all of the optional neutron runtime configuration settings are 
 * placed within a parameter list with the name "Neutron Properties".
 *
 * \subsection optional_photon_runtime_settings Optional Photon Runtime Configuration Settings
 * There are five optional photon runtime configuration settings: the
 * minimum photon energy, the Kahn sampling cutoff energy, the 
 * incoherent photon scattering model, the photon atomic relaxation mode and
 * the number of photon hash grid bins.
 *      
 * The minimum photon energy is used by FACEMC to kill photons that fall
 * below that energy. The default value is 0.001 MeV. An example specification
 * of this setting is shown below:
 * \code
 * <Parameter name="Min Photon Energy" type="double" value="1e-2"/>
 * \endcode
 *
 * The Kahn sampling cutoff energy is used when sampling from the 
 * Klein-Nishina cross section. When the photon energy is below the
 * cutoff energy Kahn's rejection sampling technique is used to sample from
 * the Klein-Nishina cross section. When above the cutoff energy Koblinger's
 * direct sampling method is used. The default value is 3.0 MeV. Note that the
 * theoretical minimum value of the cutoff energy is (1+sqrt(3))me*c^2
 * (~1.4 MeV). An example specification of this setting is shown below.
 * \code
 * <Parameter name="Kahn Sampling Cutoff Energy" type="double" value="2.5"/>
 * \endcode
 * 
 * The incoherent photon scattering model specified determines how incoherent
 * scattering is handled. There are currently eight models that can be
 * specified:
 * <ul>
 *  <li>"Klein-Nishina Model"</li>
 *  <li>"Waller-Hartree Model"</li>
 *  <li>"Impulse Model"</li>
 *  <li>"DHP Doppler Broadened Hybrid Model"</li>
 *  <li>"DFP Doppler Broadened Hybrid Model"</li>
 *  <li>"CHP Doppler Broadened Hybrid Model"</li>
 *  <li>"CFP Doppler Broadened Hybrid Model"</li>
 *  <li>"FP Doppler Broadened Impulse Model"</li>
 * </ul>
 * The "Klein-Nishina Model" assumes that all atomic electrons that are
 * interacted with are free and at rest (binding effects are ignored). 
 * The "Waller-Hartree Model" accounts for the effects of electron binding
 * on the angular distribution of outgoing photons by multiplying the 
 * Klein-Nishina cross section by the Waller-Hartree scattering function.
 * The "Impulse Model" also accounts for the effects of electron binding
 * on the angular distribution of outgoing photons. It, however, uses the
 * impulse approximation scattering function.
 * All of the Doppler broadened hybrid models use the "Waller-Hartree Model"
 * to sample outgoing photon angles and the impulse approximation to
 * sample the outgoing (Doppler broadened) photon energies. The "DHP" 
 * (Decoupled Half Profile) model samples the electron shell that is
 * interacted with independently from the electron shell where the void
 * is assumed to be after the interaction (decoupled). It also only uses
 * half of the Compton profiles for Doppler broadening. The "DFP" model
 * (Decoupled Full Profile) model is the same as the "DHP" model except
 * that the full Compton profiles are used. The "CHP" and "CFP" models
 * are the same as the "DHP" and "DFP" models respectively except that the
 * electron shell that is interacted with is also used for atomic relaxation.
 * The "FP Doppler Broadened Impulse Model" is the only consistent Doppler
 * broadening model (the impulse approximation is used to sample the outgoing
 * photon angle and energy). The full Compton profiles are also used ("FP").
 * The default model is the "CFP Doppler Broadened Hybrid Model".
 * Note that some of these models are not supported with certain data files.
 * If a model is not supported with the data files specified, FACEMC will
 * display an error message. An example specification of this setting is shown
 * below:
 * \code
 * <Parameter name="Incoherent Photon Scattering Model" type="string" value="DHP Doppler Broadened Hybrid Model"/>
 * \endcode
 *
 * The photon atomic relaxation mode can only be set to on or off (on by
 * default). It determines whether FACEMC will model atomic relaxation from
 * subshell vacancies created by photons. An example specification of this 
 * setting is shown below:  
 * \code
 * <Parameter name="Photon Atomic Relaxation" type="bool" value="false"/>
 * \endcode
 * 
 * To speed up photon cross section look-ups a hash-based scheme has been 
 * employed. The speed up is loosely correlated with the number of hash grid 
 * bins, though the correlation is system dependent. The cost of increasing the
 * number of hash grid bins is an increase in memory overhead, though this 
 * increase should be relatively small for reasonable hash grid sizes. The 
 * default number of photon hash grid bins is 1000. An example specification of
 * this setting is shown below: 
 * \code
 * <Parameter name="Photon Hash Grid Bins" type="unsigned int" value="500"/>
 * \endcode
 *
 * Note that all of the optional photon runtime configuration settings are 
 * placed within a parameter list with the name "Photon Properties".
 *
 * \subsection optional_electron_runtime_settings Optional Electron Runtime Configuration Settings
 * There are two optional electron runtime configuration settings: The
 * minimum electron energy and the electron atomic relaxation mode.
 *
 * The minimum electron energy is used by FACEMC to kill electrons that fall
 * below that energy. The default value is 1.5e-5 MeV. An example specification
 * of this setting is shown below:
 * \code
 * <Parameter name="Min Electron Energy" type="double" value="1e-3"/>
 * \endcode
 *
 * The electron atomic relaxation mode can only be set to on or off (on by
 * default). It determines whether FACEMC will model atomic relaxation from
 * subshell vacancies created by electrons. An example specification of this 
 * setting is shown below:  
 * \code
 * <Parameter name="Electron Atomic Relaxation" type="bool" value="false"/>
 * \endcode
 *
 * Note that all of the optional electron runtime configuration settings are 
 * placed within a parameter list with the name "Electron Properties".
 *
 * \subsection example_runtime_config_xml_file Advanced Runtime Configuration XML File Example
 *
 * \code
 * <ParameterList name="Properties">
 *
 * <ParameterList name="General Properties">
 *  <Parameter name="Mode" type="string" value="Neutron-Photon"/>
 *  <Parameter name="Histories" type="unsigned int" value="10"/>
 *  <Parameter name="Surface Flux Angle Cosine Cutoff" type="double" value="0.1"/>
 *  <Parameter name="Implicit Capture" type="bool" value="true"/>
 *  <Parameter name="Ideal Batches Per Processor" type="unsigned int" value="25"/>
 * </ParameterList>
 *
 * <ParameterList name="Neutron Properties">
 *  <Parameter name="Free Gas Threshold" type="double" value="600.0"/>
 *  <Parameter name="Min Neutron Energy" type="double" value="1e-2"/>
 * </ParameterList>
 *
 * <ParameterList name="Photon Properties">
 *  <Parameter name="Min Photon Energy" type="double" value="1e-2"/>
 *  <Parameter name="Kahn Sampling Cutoff Energy" type="double" value="2.5"/>
 *  <Parameter name="Photon Hash Grid Bins" type="unsigned int" value="500"/>
 *  <Parameter name="Incoherent Photon Scattering Model" type="string" value="DHP Doppler Broadened Hybrid Model"/>
 *  <Parameter name="Photon Atomic Relaxation" type="bool" value="false"/>
 * </ParameterList>
 *
 * <ParameterList name="Electron Properties">
 *  <Parameter name="Min Electron Energy" type="double" value="1e-2"/>
 *  <Parameter name="Electron Atomic Relaxation" type="bool" value="false"/>
 * </ParameterList>
 *
 * </ParameterList>
 * \endcode
 *
 * \section running_facemc Running FACEMC
 * Once all of the input XML files have been created, FACEMC can be used. To
 * see details about the FACEMC command-line interface (CLI), simply type
 * the following command
 * \code
 * facemc --help
 * \endcode
 *
 * Each of command-line arguments are listed below.
 * <ul>
 *  <li><b>sim_info</b>: The name of the XML file containing runtime
 *                       configuration information.</li>
 *  <li><b>geom_def</b>: The name of the XML file containing geometry
 *                       information.</li>
 *  <li><b>mat_def</b>: The name of the XML file containing the material
 *                      definitions.</li>
 *  <li><b>resp_def</b>: The name of the XML file containing the response
 *                       function definitions.</li>
 *  <li><b>est_def</b>: The name of the XML file containing the estimator
 *                      definitions.</li>
 *  <li><b>src_def</b>: The name of the XML file containing the source
 *                      definitions.</li>
 *  <li><b>cross_sec_dir</b>: The directory containing the desired cross
 *                            section tables (cross_sections.xml file).</li>
 *  <li><b>threads</b>: The number of threads to use (default=1, optional).</li>
 * </ul>
 *
 * The following example shows how one could use the command-line interface:
 * \code
 * facemc --sim_info=simulation.xml --geom_def=geometry.xml --mat_def=materials.xml --resp_def=responses.xml --est_def=estimators.xml --src_def=sources.xml --cross_sec_dir=/home/me/nuclear_data/ --threads=2
 * \endcode
 *
 * To get status updates on the simulations progress, simply hit control-C. 
 * This can also be used to end the simulation early. Please not that this
 * can sometimes lead to code hangs (the developers are investigating the
 * cause of these hangs).
 *
 * When a simulation finishes, a summary of the results will be printed to the 
 * screen. The results can be found in an HDF5 file called simulation.h5. This
 * file can be interacted with through python using the h5py package.
 */ 
